#include "raylib.h"
#include "raymath.h"
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

const int MAX_BULLETS = 100;
const float GRAVITY = 4.0f;
const int FONT_SIZE = 50;
const int SCREEN_WIDTH = 1280;
const int SCREEN_HEIGHT = 720;
const int QUAD_ABSOLUTE = 15.0f;

BoundingBox getBoundingBox(Model model, Vector3 pos)
{
    BoundingBox meshBox = GetMeshBoundingBox(model.meshes[0]);
    Vector3 min = Vector3Add(pos, meshBox.min);
    Vector3 max = Vector3Add(pos, meshBox.max);
    return (BoundingBox){min, max};
}

typedef struct Player {
    Vector3 pos;
    Vector3 dir;
    Model model;
    bool hasJumped;
    float hitpoints;
    float speed;
} Player;

typedef struct Bullet {
    Vector3 pos;
    Vector3 dir;
    Model model;
    bool isExpired;
    float speed;
} Bullet;

typedef struct Bullets {
    Bullet *bullets;
    int length;
    int index;
} Bullets;

typedef struct Enemy {
    Vector3 pos;
    Vector3 *target;
    Model model;
    bool isExpired;
    float speed;
} Enemy;

typedef struct Enemies {
    Enemy *enemies;
    int length;
    int index;
} Enemies;

Bullets *bullets;
Enemies *enemies;
Vector3 g0, g1, g2, g3;

void updatePlayer(Player *player, float dt)
{
    // input
    Vector2 xz = {
        (IsKeyDown(KEY_RIGHT) || IsKeyDown(KEY_D)) - (IsKeyDown(KEY_LEFT) || IsKeyDown(KEY_A)),
        (IsKeyDown(KEY_DOWN) || IsKeyDown(KEY_S)) - (IsKeyDown(KEY_UP) || IsKeyDown(KEY_W))};
    xz = Vector2Normalize(xz);
    player->dir.x = xz.x;
    player->dir.z = xz.y;
    if (!player->hasJumped && IsKeyPressed(KEY_SPACE)) {
        player->dir.y += 0.75f * GRAVITY;
        player->hasJumped = true;
    }

    // movement
    player->dir.y -= dt * GRAVITY;
    player->pos.y += player->dir.y * dt;

    BoundingBox playerBox;
    // BoundingBox obstacleBox;
    // for (int i = 0; i < bullets.length; i++) {
    playerBox = getBoundingBox(player->model, player->pos);
    //   obstacleBox = getBoundingBox(*, obstaclePos);
    // }
    // playerBox = getBoundingBox(player, pos);
    // obstacleBox = getBoundingBox(obstacle, obstaclePos);
    if (playerBox.min.y < 0) {
        player->hasJumped = false;
        player->dir.y = 0;
        player->pos.y = (playerBox.max.y - playerBox.min.y) * 0.5001;
    }
    // playerBox = getBoundingBox(player, pos);
    // obstacleBox = getBoundingBox(obstacle, obstaclePos);
    // if (CheckCollisionBoxes(playerBox, obstacleBox)) {
    //   // if (yVelo > 0) {
    //   //   pos.x =
    //   //       obstacleBox.min.x - (playerBox.max.x - playerBox.min.x) *
    //   0.5001;
    //   // }
    //   if (direction.y < 0) {
    //     hasJumped = false;
    //     direction.y = 0;
    //     pos.y = obstacleBox.max.y + (playerBox.max.y - playerBox.min.y) *
    //     0.5001;
    //   }
    // }
    player->pos.x += player->dir.x * player->speed * dt;
    // playerBox = getBoundingBox(player, pos);
    // obstacleBox = getBoundingBox(obstacle, obstaclePos);
    //
    // if (CheckCollisionBoxes(playerBox, obstacleBox)) {
    //   if (direction.x > 0) {
    //     pos.x = obstacleBox.min.x - (playerBox.max.x - playerBox.min.x) *
    //     0.5001;
    //   }
    //   if (direction.x < 0) {
    //     pos.x = obstacleBox.max.x + (playerBox.max.x - playerBox.min.x) *
    //     0.5001;
    //   }
    // }
    player->pos.z += player->dir.z * player->speed * dt;
    // playerBox = getBoundingBox(player, pos);
    // obstacleBox = getBoundingBox(obstacle, obstaclePos);
    // if (CheckCollisionBoxes(playerBox, obstacleBox)) {
    //   if (direction.z > 0) {
    //     pos.z = obstacleBox.min.z - (playerBox.max.z - playerBox.min.z) *
    //     0.5001;
    //   }
    //   if (direction.z < 0) {
    //     pos.z = obstacleBox.max.z + (playerBox.max.z - playerBox.min.z) *
    //     0.5001;
    //   }
    // }
}

void updateBullet(Bullet *bullet, float dt)
{
    // if bullet pos x and z are out of bounds, delete it
    if (bullet->pos.x < -QUAD_ABSOLUTE || bullet->pos.x > QUAD_ABSOLUTE || bullet->pos.z < -QUAD_ABSOLUTE || bullet->pos.z > QUAD_ABSOLUTE) {
        bullet->isExpired = true;
        return;
    }
    bullet->pos =
        Vector3Add(bullet->pos, Vector3Scale(bullet->dir, bullet->speed * dt));
}

void drawBullet(Bullet *bullet)
{
    DrawModelWires(bullet->model, bullet->pos, 1, BLUE);
}

void shoot(Player player, Vector3 target, Model model)
{
    Bullet bullet;
    bullet.model = model;
    bullet.pos = (Vector3){player.pos.x, player.pos.y, player.pos.z};
    bullet.dir = Vector3Normalize(Vector3Subtract(target, bullet.pos));
    Quaternion rotation = QuaternionFromVector3ToVector3((Vector3){0, 1, 0}, bullet.dir);
    Matrix rotationMatrix = QuaternionToMatrix(rotation);
    Matrix transform = MatrixMultiply(MatrixTranslate(0, 0, 0), rotationMatrix);
    bullet.model.transform = transform;
    bullet.speed = 5.0f;
    bullet.isExpired = false;

    bullets->bullets[bullets->index++] = bullet;
    if (bullets->index >= MAX_BULLETS) {
        bullets->index = 0;
    }
    if (bullets->length < MAX_BULLETS) {
        bullets->length++;
    }
}

void updateBullets(Bullets *b, float dt)
{
    int writeIndex = 0;

    for (int readIndex = 0; readIndex < b->length; readIndex++) {
        Bullet *bullet = &bullets->bullets[readIndex];
        updateBullet(bullet, dt);
        if (!bullet->isExpired) {
            if (writeIndex != readIndex) {
                b->bullets[writeIndex] = b->bullets[readIndex];
            }
            writeIndex++;
        }
    }

    b->length = writeIndex;
    b->index = writeIndex;
}

void spawnEnemy(Model model, Vector3 *target)
{
    Vector3 pos = {GetRandomValue(-QUAD_ABSOLUTE, QUAD_ABSOLUTE), 0.5, GetRandomValue(-QUAD_ABSOLUTE, QUAD_ABSOLUTE)};
    Enemy enemy = {};
    enemy.pos = pos;
    enemy.target = target;
    enemy.model = model;
    enemy.speed = GetRandomValue(1, 3);
    enemies->enemies[enemies->index++] = enemy;
    if (enemies->index >= MAX_BULLETS) {
        enemies->index = 0;
    }
    if (enemies->length < MAX_BULLETS) {
        enemies->length++;
    }
}

void updateEnemy(Enemy *enemy, float dt)
{
    Vector3 direction = Vector3Normalize(Vector3Subtract(*enemy->target, enemy->pos));
    enemy->pos =
        Vector3Add(enemy->pos, Vector3Scale(direction, enemy->speed * dt));
}

void updateEnemies(Enemies *e, float dt)
{
    int writeIndex = 0;

    for (int readIndex = 0; readIndex < e->length; readIndex++) {
        Enemy *enemy = &enemies->enemies[readIndex];
        updateEnemy(enemy, dt);
        if (!enemy->isExpired) {
            if (writeIndex != readIndex) {
                e->enemies[writeIndex] = e->enemies[readIndex];
            }
            writeIndex++;
        }
    }

    e->length = writeIndex;
    e->index = writeIndex;
}

void handleCollisions(Player *player, Bullets *bullets, Enemies *enemies)
{
    BoundingBox playerBox = getBoundingBox(player->model, player->pos);
    for (int i = 0; i < enemies->length; i++) {
        Enemy *enemy = &enemies->enemies[i];
        BoundingBox enemyBox = getBoundingBox(enemy->model, enemy->pos);
        if (CheckCollisionBoxes(playerBox, enemyBox)) {
            player->hitpoints -= 1;
            enemy->isExpired = true;
            goto next_enemy;
        }
        for (int j = 0; j < bullets->length; j++) {
            Bullet *bullet = &bullets->bullets[j];
            if (CheckCollisionBoxes(enemyBox, getBoundingBox(bullet->model, bullet->pos))) {
                enemy->isExpired = true;
                bullet->isExpired = true;
                goto next_enemy;
            }
        }
    next_enemy:
        continue;
    }
}

int main(void)
{
    // ALWAYS INIT WINDOW FIRST
    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "3d");
    SetTargetFPS(120);

    Camera3D camera = {0};
    camera.position = (Vector3){-2.0f, 10.0f, 6.0f};
    camera.target = (Vector3){0.0f, 0.0f, 0.0f};
    camera.up = (Vector3){0.0f, 1.0f, 0.0f};
    camera.fovy = 45.0f;
    camera.projection = CAMERA_PERSPECTIVE;

    float eyelineHeight = 0.5f;

    g0 = (Vector3){-QUAD_ABSOLUTE, eyelineHeight, -QUAD_ABSOLUTE};
    g1 = (Vector3){-QUAD_ABSOLUTE, eyelineHeight, QUAD_ABSOLUTE};
    g2 = (Vector3){QUAD_ABSOLUTE, eyelineHeight, QUAD_ABSOLUTE};
    g3 = (Vector3){QUAD_ABSOLUTE, eyelineHeight, -QUAD_ABSOLUTE};

    Model bulletModel = LoadModelFromMesh(GenMeshCone(0.05, 0.5, 12));
    // Model bulletModel = LoadModelFromMesh(GenMeshSphere(0.07, 12, 12));
    Model model = LoadModelFromMesh(GenMeshSphere(eyelineHeight, 12, 12));
    Vector3 pos = {0, 1, 0};
    Vector3 direction = {};
    Player player = {};
    player.pos = pos;
    player.dir = direction;
    player.model = model;
    float maxHp = 3;
    player.hitpoints = maxHp;
    player.speed = 1;
    double lastShot = 0.0f;
    float yaw = 0.0f;

    bullets = &(Bullets){};
    bullets->bullets = (Bullet *)malloc(sizeof(Bullet) * MAX_BULLETS);
    bullets->length = 0;
    bullets->index = 0;
    float rpm = 200;
    float cooldown = 60 / rpm;

    enemies = &(Enemies){};
    enemies->enemies = (Enemy *)malloc(sizeof(Enemy) * MAX_BULLETS);
    enemies->length = 0;
    enemies->index = 0;
    double lastSpawn = 0.0f;
    float enemySpawnRate = 10;

    Ray mouseRay;
    while (!WindowShouldClose()) {
        float enemyCooldown = 60 / enemySpawnRate;
        float dt = GetFrameTime();
        float currentTime = GetTime();
        yaw += 0.3f * dt;
        mouseRay = GetScreenToWorldRay(GetMousePosition(), camera);
        RayCollision groundHitInfo = GetRayCollisionQuad(mouseRay, g0, g1, g2, g3);
        Vector3 xhair = (Vector3){groundHitInfo.point.x, groundHitInfo.point.y, groundHitInfo.point.z};

        updatePlayer(&player, dt);
        if (IsMouseButtonDown(MOUSE_BUTTON_LEFT) && (currentTime - lastShot > cooldown)) {
            lastShot = currentTime;
            shoot(player, xhair, bulletModel);
        }

        if (currentTime - lastSpawn > enemyCooldown) {
            lastSpawn = currentTime;
            enemySpawnRate += 0.1f;
            spawnEnemy(model, &player.pos);
        }

        updateBullets(bullets, dt);
        updateEnemies(enemies, dt);
        handleCollisions(&player, bullets, enemies);

        BeginDrawing();
        ClearBackground(BLACK);

        BeginMode3D(camera);
        DrawGrid(100.0f, 0.5f);

        // spining globe
        player.model.transform = MatrixRotateXYZ((Vector3){0.4084, 0, yaw});
        DrawModelWires(player.model, player.pos, 1, GREEN);

        // bullets
        for (int i = 0; i < bullets->length; i++) {
            Bullet *bullet = &bullets->bullets[i];
            DrawModelWires(bullet->model, bullet->pos, 1, BLUE);
        }

        // enemies
        for (int i = 0; i < enemies->length; i++) {
            Enemy *enemy = &enemies->enemies[i];
            DrawModelWires(enemy->model, enemy->pos, 1, RED);
        }
        for (int i = 0; i < bullets->length; i++) {
            Bullet *bullet = &bullets->bullets[i];
            DrawModelWires(bullet->model, bullet->pos, 1, BLUE);
        }

        DrawLine3D(player.pos, xhair, GREEN);
        // DrawBoundingBox(getBoundingBox(player.model, player.pos), ORANGE);
        // DrawLine3D(g0, g1, RED);
        // DrawLine3D(g1, g2, RED);
        // DrawLine3D(g2, g3, RED);
        // DrawLine3D(g3, g0, RED);

        EndMode3D();

        // UI
        float value = fmax(0, cooldown - (currentTime - lastShot));
        DrawText("HP: ", 10, 10, 50, GREEN);
        for (int i = 0; i < player.hitpoints; i++) {
            DrawRectangle(100 + (i * 10) + i * 50, 10, 50, 50, GREEN);
        }
        // DrawText(TextFormat("HP: %f", player.hitpoints), 10, 50, 50, GREEN);
        EndDrawing();
    }

    CloseWindow();

    return 0;
}
